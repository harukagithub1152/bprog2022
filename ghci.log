GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/haruka/bprog2022/.ghci
2022-05-19 15:41:38.147933665
>>> 23 + 5
28
2022-05-19 15:54:27.364397619
>>> 3 + 2 * 5
13
2022-05-19 15:55:02.529391275
>>> 5 - 4 - 8
-7
2022-05-19 15:55:52.504008811
>>> sqrt 2
1.4142135623730951
2022-05-19 15:59:56.840754083
>>> double 3

<interactive>:5:1: error: Variable not in scope: double :: t0 -> t
2022-05-19 16:02:20.635708444
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/haruka/bprog2022/.ghci
2022-06-09 14:55:21.065036585
>>> 2 + 3 * 4
14
2022-06-09 14:58:40.205546333
>>> (2 + 3) * 4
20
2022-06-09 15:00:44.647767559
>>> :i sprt

<interactive>:1:1: error: Not in scope: ‘sprt’
2022-06-09 15:01:02.998542402
>>> :i sqrt
type Floating :: * -> Constraint
class Fractional a => Floating a where
  ...
  sqrt :: a -> a
  ...
  	-- Defined in ‘GHC.Float’
2022-06-09 15:01:58.959848182
>>> sqrt (3 ^ 2 + 4 ^ 2)
5.0
2022-06-09 15:05:18.058781456
>>> sqrt (25 :: Int)

<interactive>:6:1: error:
    • No instance for (Floating Int) arising from a use of ‘sqrt’
    • In the expression: sqrt (25 :: Int)
      In an equation for ‘it’: it = sqrt (25 :: Int)
2022-06-09 15:08:21.149663122
>>> sqrt (25 :: Double)
5.0
2022-06-09 15:09:23.140765481
>>> sqrt 25
5.0
2022-06-09 15:10:05.708505104
>>> head [1, 2, 3]
1
2022-06-09 15:47:04.205258087
>>> head [3, 1, 4, 1, 5]
3
2022-06-09 15:47:27.65164287
>>> head []
*** Exception: Prelude.head: empty list
2022-06-09 15:48:33.081012524
>>> hoge = [3, 1, 4, 1, 5] :: [Int]
2022-06-09 15:50:38.412103464
>>> hoge
[3,1,4,1,5]
2022-06-09 15:51:00.788835596
>>> head hoge
3
2022-06-09 15:51:30.393855734
>>> tail hoge
[1,4,1,5]
2022-06-09 15:51:36.398343919
>>> tail []
*** Exception: Prelude.tail: empty list
2022-06-09 15:52:43.785086652
>>> hoge !! 0
3
2022-06-09 15:55:21.853866345
>>> hoge !! 2
4
2022-06-09 15:56:24.876318823
>>> take 3 hoge
[3,1,4]
2022-06-09 15:57:52.124389025
>>> hoge
[3,1,4,1,5]
2022-06-09 15:57:55.684065494
>>> drop 3 hoge
[1,5]
2022-06-09 15:58:06.14347228
>>> hoge 5 hoge

<interactive>:22:1: error:
    • Couldn't match expected type: t0 -> [Int] -> t
                  with actual type: [Int]
    • The function ‘hoge’ is applied to two value arguments,
        but its type ‘[Int]’ has none
      In the expression: hoge 5 hoge
      In an equation for ‘it’: it = hoge 5 hoge
    • Relevant bindings include it :: t (bound at <interactive>:22:1)
2022-06-09 15:58:25.010340019
>>> hoge !! 5
*** Exception: Prelude.!!: index too large
2022-06-09 15:59:17.606451154
>>> take 10 hoge
[3,1,4,1,5]
2022-06-09 15:59:25.108639734
>>> drop 10 hoge
[]
2022-06-09 15:59:54.845271363
>>> length hoge
5
2022-06-09 16:01:10.234775149
>>> length []
0
2022-06-09 16:01:27.516899574
>>> sum hoge
14
2022-06-09 16:02:06.340092937
>>> product hoge
60
2022-06-09 16:02:41.268007185
>>> hoge ++ hoge
[3,1,4,1,5,3,1,4,1,5]
2022-06-09 16:04:58.065684455
>>> reverse hoge
[5,1,4,1,3]
2022-06-09 16:05:35.998627332
>>> :e src/First.hs
   1  module First where
   2  
   3  dobule :: Int -> Int
   4  dobule x = x + x
Ok, no modules loaded.
2022-06-09 16:07:49.165905933
>>> :load src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-09 16:07:49.237687175
>>> double 3 + 3

<interactive>:34:1: error:
    • Variable not in scope: double :: t0 -> a
    • Perhaps you meant ‘dobule’ (line 4)
2022-06-09 16:08:01.532754753
>>> :e src/First.hs
   1  module First where
   2  
   3  dobule :: Int -> Int
   4  dobule x = x + x
Ok, one module loaded.
2022-06-09 16:09:26.520194361
>>> :load src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-09 16:09:26.621281003
>>> double 3 + 3

<interactive>:37:1: error:
    • Variable not in scope: double :: t0 -> a
    • Perhaps you meant ‘dobule’ (line 4)
2022-06-09 16:09:44.673552953
>>> double 3 + 3

<interactive>:38:1: error:
    • Variable not in scope: double :: t0 -> a
    • Perhaps you meant ‘dobule’ (line 4)
2022-06-09 16:17:48.034520224
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-09 16:19:58.97527908
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-09 16:19:59.071441387
>>> double 3 + 3
9
2022-06-09 16:29:43.661921138
>>> double (3 + 3)
12
2022-06-09 16:30:02.213922738
>>> : qwit
target ‘qwit’ is not a module name or a source file
2022-06-09 16:30:27.629825082
>>> : gwit
target ‘gwit’ is not a module name or a source file
2022-06-09 16:30:52.489938733
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
Ok, one module loaded.
2022-06-09 16:37:06.433873491
>>> Quadruple 2

<interactive>:46:1: error:
    • Data constructor not in scope: Quadruple :: t0 -> t
    • Perhaps you meant variable ‘quadruple’ (line 7)
2022-06-09 16:37:37.26063322
>>> quadruble 2

<interactive>:47:1: error:
    • Variable not in scope: quadruble :: t0 -> t
    • Perhaps you meant ‘quadruple’ (line 7)
2022-06-09 16:39:04.000506724
>>> quadruple 2
8
2022-06-09 16:39:24.521716026
>>> quadruple (2 + 3)
20
2022-06-09 16:40:03.851688526
>>> :quit
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/haruka/bprog2022/.ghci
2022-06-16 15:02:13.248341293
>>> take 3 [3,1,4,1,5]
[3,1,4]
2022-06-16 15:04:21.881162588
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
Ok, no modules loaded.
2022-06-16 15:10:53.671968717
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:10:53.746149728
>>> double

<interactive>:4:1: error:
    • No instance for (Show (Int -> Int)) arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-06-16 15:13:01.489235087
>>> take (double 2) [1,2,3,4,5]
[1,2,3,4]
2022-06-16 15:15:15.334542484
>>> [1 .. 10]
[1,2,3,4,5,6,7,8,9,10]
2022-06-16 15:20:31.887038813
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: integer -> integer
  10  factorial n = product [1 .. n]
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:10:15: error:
    • No instance for (Num integer) arising from a use of ‘product’
      Possible fix:
        add (Num integer) to the context of
          the type signature for:
            factorial :: forall integer. integer -> integer
    • In the expression: product [1 .. n]
      In an equation for ‘factorial’: factorial n = product [1 .. n]
   |
10 | factorial n = product [1 .. n]
   |               ^^^^^^^^^^^^^^^^

src/First.hs:10:23: error:
    • No instance for (Enum integer)
        arising from the arithmetic sequence ‘1 .. n’
      Possible fix:
        add (Enum integer) to the context of
          the type signature for:
            factorial :: forall integer. integer -> integer
    • In the first argument of ‘product’, namely ‘[1 .. n]’
      In the expression: product [1 .. n]
      In an equation for ‘factorial’: factorial n = product [1 .. n]
   |
10 | factorial n = product [1 .. n]
   |                       ^^^^^^^^
Failed, no modules loaded.
2022-06-16 15:21:07.865636928
>>> 
2022-06-16 15:22:22.660800302
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:22:38.11582117
>>> factorial 3
6
2022-06-16 15:22:59.222864884
>>> factorial 4
24
2022-06-16 15:23:13.235082862
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int]-> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int]-> Int
  16  ave xs = div (sum xs) (length xs)
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:38:22.671257901
>>> average [1,2,3,4,5]
3
2022-06-16 15:38:38.877880685
>>> :t take 3 [1,2,3,4,5]
take 3 [1,2,3,4,5] :: Num a => [a]
2022-06-16 15:49:51.611960967
>>> init [1 .. 5]
[1,2,3,4]
2022-06-16 16:07:10.410238979
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int]-> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int]-> Int
  16  ave xs = div (sum xs) (length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit (x:[]) = []
  20  myinit (x:xs) = x : (init xs)
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 16:14:36.261513434
>>> myinit [1 .. 5]
[1,2,3,4]
2022-06-16 16:14:49.213837049
>>> myinit []
*** Exception: src/First.hs:(19,1)-(20,29): Non-exhaustive patterns in function myinit

2022-06-16 16:15:03.481421608
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/haruka/bprog2022/.ghci
2022-06-23 14:54:49.440130232
>>> :i Num
type Num :: * -> Constraint
class Num a where
  (+) :: a -> a -> a
  (-) :: a -> a -> a
  (*) :: a -> a -> a
  negate :: a -> a
  abs :: a -> a
  signum :: a -> a
  fromInteger :: Integer -> a
  {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}
  	-- Defined in ‘GHC.Num’
instance Num NominalDiffTime
  -- Defined in ‘time-1.9.3:Data.Time.Clock.Internal.NominalDiffTime’
instance Num DiffTime
  -- Defined in ‘time-1.9.3:Data.Time.Clock.Internal.DiffTime’
instance Num Word -- Defined in ‘GHC.Num’
instance Num Integer -- Defined in ‘GHC.Num’
instance Num Int -- Defined in ‘GHC.Num’
instance Num Float -- Defined in ‘GHC.Float’
instance Num Double -- Defined in ‘GHC.Float’
2022-06-23 14:56:38.87469101
>>> 1 == 2
False
2022-06-23 15:06:21.941690243
>>> 1 <= 2
True
2022-06-23 15:06:31.000819472
>>> 1 < 1
False
2022-06-23 15:06:40.381440928
>>> 1 <= 2
True
2022-06-23 15:06:50.784568417
>>> 1 >= 2
False
2022-06-23 15:07:01.419248901
>>> 'a' < 'b'
True
2022-06-23 15:11:29.219286239
>>> 'a' < B

<interactive>:8:7: error: Data constructor not in scope: B :: Char
2022-06-23 15:11:41.821963093
>>> 'a' < 'B'
False
2022-06-23 15:11:52.795656871
>>> '' < 'a'

<interactive>:10:1: error:
    Parser error on `''`
    Character literals may not be empty
2022-06-23 15:12:20.140470967
>>> 'ab' < 'd'

<interactive>:11:1: error:
    • Syntax error on 'ab'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'ab'
2022-06-23 15:13:04.375266637
>>> 1 /= 2
True
2022-06-23 15:16:15.968789224
>>> 1 /= 1
False
2022-06-23 15:16:22.877381447
>>> :info abs
type Num :: * -> Constraint
class Num a where
  ...
  abs :: a -> a
  ...
  	-- Defined in ‘GHC.Num’
2022-06-23 15:30:13.570211196
>>> abs

<interactive>:15:1: error:
    • No instance for (Show (Integer -> Integer))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-06-23 15:30:55.606335981
>>> abs (-234)
234
2022-06-23 15:34:43.977496693
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/haruka/bprog2022/.ghci
2022-06-30 14:56:31.038849871
>>> [ x ^ 2 | x <- [1 .. 5] ]
[1,4,9,16,25]
2022-06-30 15:02:06.760136661
>>> map (^2) [1..5]
[1,4,9,16,25]
2022-06-30 15:05:12.902446707
>>> [ x * 2 | x <- [1 .. 5] ]
[2,4,6,8,10]
2022-06-30 15:12:42.540893183
>>> [ x `div` 2 | x <- [1 .. 5] ]
[0,1,1,2,2]
2022-06-30 15:13:40.948675686
>>> [ x `divmod` 2 | x <- {1 .. 5] ]

<interactive>:5:23: error: parse error on input ‘{’
2022-06-30 15:16:19.611643367
>>> [ x `divmod` 2 | x <- [1 .. 5]]

<interactive>:6:5: error:
    • Variable not in scope: divmod :: t0 -> t1 -> a
    • Perhaps you meant ‘divMod’ (imported from Prelude)
2022-06-30 15:16:54.225596666
>>> [ (x, y) | x <- "abc" , y <- [4,5] ]
[('a',4),('a',5),('b',4),('b',5),('c',4),('c',5)]
2022-06-30 15:20:59.558837129
>>> [ (x, y ) | y <- [4,5], x <- "abc" ]
[('a',4),('b',4),('c',4),('a',5),('b',5),('c',5)]
2022-06-30 15:21:54.874286459
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int]-> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int]-> Int
  16  ave xs = div (sum xs) (length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit (x:[]) = []
  20  myinit (x:xs) = x : (init xs)
  21  
  22  myconcat :: [[a]] -> [a]
  23  myconcat xss = [ x | xs <- xss, x <- xs ]
Ok, no modules loaded.
2022-06-30 15:30:01.952081843
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-30 15:30:02.035297889
>>> [ 1 | _ <- [1 .. 5] ]
[1,1,1,1,1]
2022-06-30 15:47:41.701782271
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int]-> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int]-> Int
  16  ave xs = div (sum xs) (length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit (x:[]) = []
  20  myinit (x:xs) = x : (init xs)
  21  
  22  myconcat :: [[a]] -> [a]
  23  myconcat xss = [ x | xs <- xss, x <- xs ]
  24  
  25  mylength :: [a] -> Int
  26  mylength xs = sum [ 1 | _ <- xs ]
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-30 15:50:11.158159886
>>> mylength ['a' .. 'z']
26
2022-06-30 15:50:42.330013049
>>> ['a' .. 'z']
"abcdefghijklmnopqrstuvwxyz"
2022-06-30 15:51:03.483302169
>>> ['あ' .. 'ん']
"\12354\12355\12356\12357\12358\12359\12360\12361\12362\12363\12364\12365\12366\12367\12368\12369\12370\12371\12372\12373\12374\12375\12376\12377\12378\12379\12380\12381\12382\12383\12384\12385\12386\12387\12388\12389\12390\12391\12392\12393\12394\12395\12396\12397\12398\12399\12400\12401\12402\12403\12404\12405\12406\12407\12408\12409\12410\12411\12412\12413\12414\12415\12416\12417\12418\12419\12420\12421\12422\12423\12424\12425\12426\12427\12428\12429\12430\12431\12432\12433\12434\12435"
2022-06-30 15:52:12.699762884
>>> putStrLn it
あぃいぅうぇえぉおかがきぎくぐけげこごさざしじすずせぜそぞただちぢっつづてでとどなにぬねのはばぱひびぴふぶぷへべぺほぼぽまみむめもゃやゅゆょよらりるれろゎわゐゑをん
2022-06-30 15:56:45.933629121
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/haruka/bprog2022/.ghci
2022-07-07 16:05:11.466328252
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
Ok, no modules loaded.
2022-07-07 16:05:35.437035746
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-07 16:05:35.523045076
>>> ord 'A'
65
2022-07-07 16:05:58.490620202
>>> ord 'a'
97
2022-07-07 16:06:11.115048509
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/haruka/bprog2022/.ghci
2022-07-14 15:11:31.44545192
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c
Ok, no modules loaded.
2022-07-14 15:11:53.069487907
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:11:53.154372304
>>> let2int 'a'
97
2022-07-14 15:12:57.060582013
>>> let2int 'z'
122
2022-07-14 15:13:51.615609573
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:15:24.255489494
>>> let2int 'a'
0
2022-07-14 15:15:46.369613996
>>> let2int 'z'
25
2022-07-14 15:16:01.434172621
>>> ord 'a'
97
2022-07-14 15:19:22.152105117
>>> chr 97
'a'
2022-07-14 15:19:31.501998701
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (i + ord 'a')
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:20:19.559834164
>>> int2let 0
'a'
2022-07-14 15:20:26.411133234
>>> int2let 25
'z'
2022-07-14 15:20:36.747134446
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13       | isLower c = int2let ((let2int c + n) `mod` 26)
  14       | otherwise = c
  15       
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:27:44.439306971
>>> shift 3 'a'
'd'
2022-07-14 15:28:02.588507294
>>> shift (-3) 'd'
'a'
2022-07-14 15:28:20.031019357
>>> shift 3 'z'
'c'
2022-07-14 15:30:00.719038436
>>> shift 3 ' '
' '
2022-07-14 15:33:06.610298466
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13       | isLower c = int2let ((let2int c + n) `mod` 26)
  14       | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:36:13.907502161
>>> encode 3 "haskell is fun"
"kdvnhoo lv ixq"
2022-07-14 15:36:43.26958641
>>> encode 3 "haskell is fun"
"kdvnhoo lv ixq"
2022-07-14 15:48:12.235520473
>>> it
"kdvnhoo lv ixq"
2022-07-14 15:48:36.571754599
>>> encode (-3) it
"haskell is fun"
2022-07-14 15:49:09.59673815
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13       | isLower c = int2let ((let2int c + n) `mod` 26)
  14       | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24   
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:59:28.864531641
>>> length table
26
2022-07-14 15:59:49.190926937
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13       | isLower c = int2let ((let2int c + n) `mod` 26)
  14       | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24   
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 16:09:03.604153908
>>> percent 5 15
33.333336
2022-07-14 16:09:15.746435793
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13       | isLower c = int2let ((let2int c + n) `mod` 26)
  14       | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24   
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = lenght [ x' | x' <- xs, x == x']
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:29:14: error:
    • Variable not in scope: lenght :: [Char] -> Int
    • Perhaps you meant ‘length’ (imported from Prelude)
   |
29 | count x xs = lenght [ x' | x' <- xs, x == x']
   |              ^^^^^^
Failed, no modules loaded.
2022-07-14 16:15:27.391638718
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13       | isLower c = int2let ((let2int c + n) `mod` 26)
  14       | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24   
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 16:15:44.45977437
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/haruka/bprog2022/.ghci
2022-07-30 23:42:51.000871806
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13       | isLower c = int2let ((let2int c + n) `mod` 26)
  14       | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24   
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = lenght xs
Ok, no modules loaded.
2022-07-30 23:43:53.349270044
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:34:13: error:
    • Variable not in scope: lenght :: String -> t
    • Perhaps you meant ‘length’ (imported from Prelude)
   |
34 |         n = lenght xs
   |             ^^^^^^
Failed, no modules loaded.
2022-07-30 23:43:53.496248209
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13       | isLower c = int2let ((let2int c + n) `mod` 26)
  14       | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24   
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-30 23:44:50.724746578
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-30 23:44:50.823257968
>>> length sample

<interactive>:5:8: error: Variable not in scope: sample :: t0 a0
2022-07-30 23:47:48.646402848
>>> sample

<interactive>:6:1: error: Variable not in scope: sample
2022-07-30 23:48:25.680715217
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13       | isLower c = int2let ((let2int c + n) `mod` 26)
  14       | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24   
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-30 23:50:10.961970546
>>> length sample
15
2022-07-30 23:50:41.611435173
>>> sample
"abbcccddddeeeee"
2022-07-30 23:51:26.381816134
>>> freqs sample
[6.666667,13.333334,20.0,26.666668,33.333336,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]
2022-07-30 23:52:06.619355953
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13       | isLower c = int2let ((let2int c + n) `mod` 26)
  14       | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24   
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ (o - e)^2 / e | (o,e) <- zip os es ]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-31 00:03:19.725794273
>>> rotate 3 [1,2,3,4,5]
[4,5,1,2,3]
2022-07-31 00:04:10.253861912
>>> table'

<interactive>:13:1: error:
    • Variable not in scope: table'
    • Perhaps you meant ‘table’ (line 20)
2022-07-31 00:06:24.059369671
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13       | isLower c = int2let ((let2int c + n) `mod` 26)
  14       | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24   
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ (o - e)^2 / e | (o,e) <- zip os es ]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
  44  
  45  table' ::[Flote]
  46  table' = freqs "kbvnhoo lv ixp"
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:45:11: error:
    Not in scope: type constructor or class ‘Flote’
   |
45 | table' ::[Flote]
   |           ^^^^^
Failed, no modules loaded.
2022-07-31 00:07:10.440143528
>>> table'

<interactive>:15:1: error: Variable not in scope: table'
2022-07-31 00:07:50.933740553
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13       | isLower c = int2let ((let2int c + n) `mod` 26)
  14       | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24   
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ (o - e)^2 / e | (o,e) <- zip os es ]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
  44  
  45  table' ::[Float]
  46  table' = freqs "kbvnhoo lv ixp"
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-31 00:08:11.646204271
>>> table'
[0.0,7.1428576,0.0,0.0,0.0,0.0,0.0,7.1428576,7.1428576,0.0,7.1428576,7.1428576,0.0,7.1428576,14.285715,7.1428576,0.0,0.0,0.0,0.0,0.0,14.285715,0.0,7.1428576,0.0,0.0]
2022-07-31 00:08:23.535186738
>>> [chisqr (rotate n table' ) table | n <- [0 .. 25] ]
[575.63074,440.28806,928.9678,183.61263,796.3546,3169.2878,467.5709,606.94037,672.02136,738.74817,368.04318,1578.8295,1715.6287,538.7333,1094.4086,2217.831,995.6459,1643.7017,1197.4364,306.58292,747.8385,612.42474,2140.828,684.19305,3895.2554,978.1598]
2022-07-31 00:10:13.054792958
>>> [chisqr (rotate n table') table | n <- [0 .. 25] ]
[575.63074,440.28806,928.9678,183.61263,796.3546,3169.2878,467.5709,606.94037,672.02136,738.74817,368.04318,1578.8295,1715.6287,538.7333,1094.4086,2217.831,995.6459,1643.7017,1197.4364,306.58292,747.8385,612.42474,2140.828,684.19305,3895.2554,978.1598]
2022-07-31 00:13:55.77275036
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13       | isLower c = int2let ((let2int c + n) `mod` 26)
  14       | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24   
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ (o - e)^2 / e | (o,e) <- zip os es ]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
  44  
  45  table' ::[Float]
  46  table' = freqs sampleAngou
  47  
  48  sampleAngou :: String
  49  sampleAngou = "kdvnhoo lv ixq"
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-31 00:18:02.137187043
>>> [chisqr (rotate n table') table | n <- [0 .. 25] ]
[1037.1161,472.26096,451.96503,150.75772,1059.9601,3122.5193,480.326,857.7907,716.2974,731.72504,367.52783,1095.8976,1689.1488,1036.0608,1097.8545,2231.09,486.6004,2085.8784,725.49756,596.9133,964.8147,627.002,2138.5535,703.25635,3905.8936,462.25485]
2022-07-31 00:19:42.426326315
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13       | isLower c = int2let ((let2int c + n) `mod` 26)
  14       | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24   
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ (o - e)^2 / e | (o,e) <- zip os es ]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
  44  
  45  table' ::[Float]
  46  table' = freqs sampleAngou
  47  
  48  sampleAngou :: String
  49  sampleAngou = "kdvnhoo lv ixq"
  50  
  51  crack :: String -> String
  52  crack xs = encode (-factor) xs
  53      where
  54          factor = head (positions (minimum chited) chited)
  55          chited = [chisqr (rotate n table') table | n <- [0 .. 25]]
  56          table' = freqs xs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:54:24: error:
    Variable not in scope: positions :: Float -> [Float] -> [a]
   |
54 |         factor = head (positions (minimum chited) chited)
   |                        ^^^^^^^^^
Failed, no modules loaded.
2022-07-31 00:26:25.985789493
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13       | isLower c = int2let ((let2int c + n) `mod` 26)
  14       | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24   
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ (o - e)^2 / e | (o,e) <- zip os es ]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
  44  
  45  table' ::[Float]
  46  table' = freqs sampleAngou
  47  
  48  sampleAngou :: String
  49  sampleAngou = "kdvnhoo lv ixq"
  50  
  51  crack :: String -> String
  52  crack xs = encode (-factor) xs
  53      where
  54          factor = head (positions (minimum chited) chited)
  55          chited = [chisqr (rotate n table') table | n <- [0 .. 25]]
  56          table' = freqs xs
  57  
  58          positions :: Eq a => a -> [a] -> [Int]
  59          positions x xs = [ i | (x',i)<- zip xs [0 ..]]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-31 00:29:36.39790867
>>> positions False [True, False, True, False]

<interactive>:24:1: error:
    Variable not in scope: positions :: Bool -> [Bool] -> t
2022-07-31 00:31:24.467148656
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13       | isLower c = int2let ((let2int c + n) `mod` 26)
  14       | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24   
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ (o - e)^2 / e | (o,e) <- zip os es ]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
  44  
  45  table' ::[Float]
  46  table' = freqs sampleAngou
  47  
  48  sampleAngou :: String
  49  sampleAngou = "kdvnhoo lv ixq"
  50  
  51  crack :: String -> String
  52  crack xs = encode (-factor) xs
  53      where
  54          factor = head (positions (minimum chited) chited)
  55          chited = [chisqr (rotate n table') table | n <- [0 .. 25]]
  56          table' = freqs xs
  57  
  58          positions :: Eq a => a -> [a] -> [Int]
  59          positions x xs = [ i | (x',i)<- zip xs [0 ..], x == X']
  60          
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:59:61: error:
    • Data constructor not in scope: X'
    • Perhaps you meant variable ‘x'’ (line 59)
   |
59 |         positions x xs = [ i | (x',i)<- zip xs [0 ..], x == X']
   |                                                             ^^
Failed, no modules loaded.
2022-07-31 00:32:21.940306463
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13       | isLower c = int2let ((let2int c + n) `mod` 26)
  14       | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24   
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ (o - e)^2 / e | (o,e) <- zip os es ]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
  44  
  45  table' ::[Float]
  46  table' = freqs sampleAngou
  47  
  48  sampleAngou :: String
  49  sampleAngou = "kdvnhoo lv ixq"
  50  
  51  crack :: String -> String
  52  crack xs = encode (-factor) xs
  53      where
  54          factor = head (positions (minimum chited) chited)
  55          chited = [chisqr (rotate n table') table | n <- [0 .. 25]]
  56          table' = freqs xs
  57  
  58          positions :: Eq a => a -> [a] -> [Int]
  59          positions x xs = [ i | (x',i)<- zip xs [0 ..], x == x']
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-31 00:33:35.834768391
>>> positions False [True, False, True, False]

<interactive>:27:1: error:
    Variable not in scope: positions :: Bool -> [Bool] -> t
2022-07-31 00:35:12.778405097
>>> crack sampleAngou
"haskell is fun"
2022-07-31 00:38:17.09445829
>>> crack "vscd mywzboroxcsyxc kbo ecopev"
"list comprehensions are useful"
2022-07-31 00:42:44.238535879
>>> :q
Leaving GHCi.
